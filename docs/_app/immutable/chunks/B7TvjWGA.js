import{aF as O,N as x}from"./DwWpeHsS.js";import{O as C}from"./Cu8jEwIa.js";import{e as F}from"./aQ5IuZRd.js";import{Q as k}from"./fFYBqOqn.js";import{t as A,n as I}from"./WCVSSNPR.js";import{f as w}from"./BfMV86KQ.js";import{a as R}from"./D7TN9t_q.js";import{d as U,a as N,b as B}from"./CMa4WlQ_.js";import{U as J,m as V,c as T,S as q}from"./DodjHqio.js";import{G as $}from"./Bi24p-5_.js";function z(i,t,l,n){const{rendererJSON:c,isRGBRenderer:m}=i;let o=null,f=null;if(t&&m)o=t;else if(t&&c?.type==="pointCloudUniqueValueRenderer"){f=U.fromJSON(c);const e=f.colorUniqueValueInfos;o=new Uint8Array(3*n);const s=g(f.fieldTransformType);for(let r=0;r<n;r++){const a=(s?s(t[r]):t[r])+"";for(let u=0;u<e.length;u++)if(e[u].values.includes(a)){o[3*r]=e[u].color.r,o[3*r+1]=e[u].color.g,o[3*r+2]=e[u].color.b;break}}}else if(t&&c?.type==="pointCloudStretchRenderer"){f=N.fromJSON(c);const e=f.stops;o=new Uint8Array(3*n);const s=g(f.fieldTransformType);for(let r=0;r<n;r++){const a=s?s(t[r]):t[r],u=e.length-1;if(a<e[0].value)o[3*r]=e[0].color.r,o[3*r+1]=e[0].color.g,o[3*r+2]=e[0].color.b;else if(a>=e[u].value)o[3*r]=e[u].color.r,o[3*r+1]=e[u].color.g,o[3*r+2]=e[u].color.b;else for(let b=1;b<e.length;b++)if(a<e[b].value){const p=(a-e[b-1].value)/(e[b].value-e[b-1].value);o[3*r]=e[b].color.r*p+e[b-1].color.r*(1-p),o[3*r+1]=e[b].color.g*p+e[b-1].color.g*(1-p),o[3*r+2]=e[b].color.b*p+e[b-1].color.b*(1-p);break}}}else if(t&&c?.type==="pointCloudClassBreaksRenderer"){f=B.fromJSON(c);const e=f.colorClassBreakInfos;o=new Uint8Array(3*n);const s=g(f.fieldTransformType);for(let r=0;r<n;r++){const a=s?s(t[r]):t[r];for(let u=0;u<e.length;u++)if(a>=e[u].minValue&&a<=e[u].maxValue){o[3*r]=e[u].color.r,o[3*r+1]=e[u].color.g,o[3*r+2]=e[u].color.b;break}}}else o=new Uint8Array(3*n).fill(255);if(l&&f?.colorModulation){const e=f.colorModulation.minValue,s=f.colorModulation.maxValue,r=.3;for(let a=0;a<n;a++){const u=l[a],b=u>=s?1:u<=e?r:r+(1-r)*(u-e)/(s-e);o[3*a]=b*o[3*a],o[3*a+1]=b*o[3*a+1],o[3*a+2]=b*o[3*a+2]}}return o}function E(i,t){if(i.encoding==null||i.encoding===""){const l=J(t,i);if(l.vertexAttributes.position==null)return;const n=V(t,l.vertexAttributes.position),c=l.header.fields,m=[c.offsetX,c.offsetY,c.offsetZ],o=[c.scaleX,c.scaleY,c.scaleZ],f=n.length/3,e=new Float64Array(3*f);for(let s=0;s<f;s++)e[3*s]=n[3*s]*o[0]+m[0],e[3*s+1]=n[3*s+1]*o[1]+m[1],e[3*s+2]=n[3*s+2]*o[2]+m[2];return e}if(i.encoding==="lepcc-xyz")return T(t).result}function h(i,t,l){return i?.attributeInfo.useElevation?t?G(t,l):null:i?.attributeInfo.storageInfo?q(i.attributeInfo.storageInfo,i.buffer,l,!0):null}function G(i,t){const l=new Float64Array(t);for(let n=0;n<t;n++)l[n]=i[3*n+2];return l}function X(i,t,l,n,c){const m=i.length/3;let o=0;for(let f=0;f<m;f++){let e=!0;for(let s=0;s<n.length&&e;s++){const{filterJSON:r}=n[s],a=c[s].values[f];switch(r.type){case"pointCloudValueFilter":{const u=r.mode==="exclude";r.values.includes(a)===u&&(e=!1);break}case"pointCloudBitfieldFilter":{const u=M(r.requiredSetBits),b=M(r.requiredClearBits);(a&u)===u&&(a&b)===0||(e=!1);break}case"pointCloudReturnFilter":{const u=15&a,b=a>>>4&15,p=b>1,D=u===1,y=u===b;let v=!1;for(const d of r.includedReturns)if(d==="last"&&y||d==="firstOfMany"&&D&&p||d==="lastOfMany"&&y&&p||d==="single"&&!p){v=!0;break}v||(e=!1);break}}}e&&(l[o]=f,i[3*o]=i[3*f],i[3*o+1]=i[3*f+1],i[3*o+2]=i[3*f+2],t[3*o]=t[3*f],t[3*o+1]=t[3*f+1],t[3*o+2]=t[3*f+2],o++)}return o}function g(i){switch(i){default:case null:case"none":return t=>t;case"low-four-bit":return t=>15&t;case"high-four-bit":return t=>(240&t)>>4;case"absolute-value":return t=>Math.abs(t);case"modulo-ten":return t=>t%10}}function M(i){let t=0;for(const l of i||[])t|=1<<l;return t}class Y{transform(t){const l=this._transform(t),n=[l.points.buffer,l.rgb.buffer];l.pointIdFilterMap!=null&&n.push(l.pointIdFilterMap.buffer);for(const c of l.attributes)"buffer"in c.values&&O(c.values.buffer)&&c.values.buffer!==l.rgb.buffer&&n.push(c.values.buffer);return Promise.resolve({result:l,transferList:n})}_transform(t){const l=E(t.schema,t.geometryBuffer);let n=l.length/3,c=null;const m=new Array,o=h(t.primaryAttributeData,l,n);t.primaryAttributeData!=null&&o&&m.push({attributeInfo:t.primaryAttributeData.attributeInfo,values:o});const f=h(t.modulationAttributeData,l,n);t.modulationAttributeData!=null&&f&&m.push({attributeInfo:t.modulationAttributeData.attributeInfo,values:f});let e=z(t.rendererInfo,o,f,n);if(t.filterInfo&&t.filterInfo.length>0&&t.filterAttributesData!=null){const r=t.filterAttributesData.filter(x).map(a=>{const u=h(a,l,n),b={attributeInfo:a.attributeInfo,values:u};return m.push(b),b});c=new Uint32Array(n),n=X(l,e,c,t.filterInfo,r)}for(const r of t.userAttributesData){const a=h(r,l,n);m.push({attributeInfo:r.attributeInfo,values:a})}3*n<e.length&&(e=new Uint8Array(e.buffer.slice(0,3*n))),_(l,n,t.elevationOffset);const s=Z(l,n,$.fromData(t.obbData),w.fromJSON(t.inSR),w.fromJSON(t.outSR));return{obbData:t.obbData,points:s,rgb:e,attributes:m,pointIdFilterMap:c}}}function Z(i,t,l,n,c){if(!R(i,n,0,i,c,0,t))throw new Error("Can't reproject");const m=A(l.center),o=I(),f=I(),e=A(l.halfSize);C(S,l.quaternion);const s=new Float32Array(3*t);for(let r=0;r<t;r++){let a=3*r;o[0]=i[a]-m[0],o[1]=i[a+1]-m[1],o[2]=i[a+2]-m[2],k(f,o,S),e[0]=Math.max(e[0],Math.abs(f[0])),e[1]=Math.max(e[1],Math.abs(f[1])),e[2]=Math.max(e[2],Math.abs(f[2])),s[a++]=o[0],s[a++]=o[1],s[a]=o[2]}return l.halfSize=e,s}function _(i,t,l){if(l!==0)for(let n=0;n<t;n++)i[3*n+2]+=l}const S=F();function rt(){return new Y}export{rt as default};
