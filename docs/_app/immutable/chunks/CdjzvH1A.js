import{l as c}from"./CCbunvHC.js";import{_ as d,m as p,a as u}from"./Chk7m36c.js";import{O as f}from"./DKTxA4NN.js";import{n as m}from"./CbsNIDjS.js";import{i as l}from"./DSdBzmdi.js";import{C as b}from"./gvnm7ut2.js";import"./BFGjv385.js";import{b as g}from"./D-HPEf1Q.js";function M(i){return new c({getCollections:()=>[i.tables,i.layers],getChildrenFunction:a=>{const o=[];return"tables"in a&&o.push(a.tables),"layers"in a&&o.push(a.layers),o},itemFilterFunction:a=>{const o=a.parent;return!!o&&"tables"in o&&o.tables.includes(a)}})}function B(i){for(const a of i.values())a?.destroy();i.clear()}function y(i,a,o){let e,t;if(i)for(let r=0,n=i.length;r<n;r++){if(e=i.at(r),e?.[a]===o)return e;if(e?.type==="group"&&(t=y(e.layers,a,o),t))return t}}const I=i=>{const a=i;let o=class extends a{constructor(...e){super(...e),this.layers=new f;const t=s=>{s.parent&&s.removeFromParent()},r=s=>{s.parent=this,this.layerAdded(s),s.type!=="elevation"&&s.type!=="base-elevation"||l.getLogger(this).error(`Layer 'title:${s.title}, id:${s.id}' of type '${s.type}' is not supported as an operational layer and will therefore be ignored.`)},n=s=>{s.parent=null,this.layerRemoved(s)};this.addHandles([this.layers.on("before-add",s=>{if(s.item===this)return s.preventDefault(),void l.getLogger(this).error("#add()","Cannot add layer to itself.");t(s.item)}),this.layers.on("after-add",s=>r(s.item)),this.layers.on("after-remove",s=>n(s.item))])}destroy(){const e=this.layers.toArray();for(const t of e)t.destroy();this.layers.destroy()}removeChildLayer(e){this.layers.remove(e),super.removeChildLayer?.(e)}set layers(e){this._set("layers",m(e,this._get("layers")))}add(e,t){const r=this.layers;if(t=r.getNextIndex(t),e instanceof g){const n=e;n.parent===this?this.reorder(n,t):r.add(n,t)}else b(e)?e.then(n=>{this.destroyed||this.add(n,t)}):l.getLogger(this).error("#add()","The item being added is not a Layer or a Promise that resolves to a Layer.")}addMany(e,t){const r=this.layers;let n=r.getNextIndex(t);e.slice().forEach(s=>{s.parent!==this?(r.add(s,n),n+=1):this.reorder(s,n)})}findLayerById(e){return y(this.layers,"id",e)}findLayerByUid(e){return y(this.layers,"uid",e)}remove(e){return this.layers.remove(e)}removeMany(e){return this.layers.removeMany(e)}removeAll(){return this.layers.removeAll()}reorder(e,t){return this.layers.reorder(e,t)}layerAdded(e){}layerRemoved(e){}};return d([p()],o.prototype,"layers",null),o=d([u("esri.support.LayersMixin")],o),o},v=new Set(["feature","subtype-group"]);function h(i,a,o){if(i)for(let e=0,t=i.length;e<t;e++){const r=i.at(e);if(r[a]===o)return r;if(r?.type==="group"){const n=h(r.tables,a,o);if(n)return n}}}const T=i=>{const a=i;let o=class extends a{constructor(...e){super(...e),this.tables=new f,this.addHandles([this.tables.on("after-add",t=>{const r=t.item;r.parent&&r.parent!==this&&r.removeFromParent(),r.parent=this,v.has(r.type)||l.getLogger(this).error(`Layer 'title:${r.title}, id:${r.id}' of type '${r.type}' is not supported as a table and will therefore be ignored.`)}),this.tables.on("after-remove",t=>{t.item.parent=null})])}destroy(){const e=this.tables.toArray();for(const t of e)t.destroy();this.tables.destroy()}removeChildLayer(e){this.tables.remove(e),super.removeChildLayer?.(e)}set tables(e){this._set("tables",m(e,this._get("tables")))}findTableById(e){return h(this.tables,"id",e)}findTableByUid(e){return h(this.tables,"uid",e)}};return d([p()],o.prototype,"tables",null),o=d([u("esri.support.TablesMixin")],o),o};export{I as a,B as b,T as n,M as t};
