import{b as a}from"./BFGjv385.js";import{s as e,i as h,u as c}from"./D5J0HRgs.js";import"./CQL0hffV.js";import{q as m,N as l}from"./CaRPOetq.js";import{K as p,x as u}from"./BCRaCWYj.js";import"./MhViydJc.js";import"./BjmdJBfY.js";import"./lWokueJ2.js";import"./bnayRBMH.js";function I(){return a("curve-densification-coarse-segments")}function f(){return a("curve-densification-max-segments")}function j(){return a("curve-densification-min-segments")}function w(){return a("curve-densification-pixel-deviation")}class F{constructor(s,i,n){this.uid=s,this.geometry=i,this.attributes=n,this.visible=!0,this.objectId=null,this.centroid=null}}function N(t){return t.geometry!=null}class ${constructor(){this.exceededTransferLimit=!1,this.features=[],this.fields=[],this.hasM=!1,this.hasZ=!1,this.geometryType=null,this.objectIdFieldName=null,this.globalIdFieldName=null,this.geometryProperties=null,this.geohashFieldName=null,this.spatialReference=null,this.transform=null}}function R(t){if(t==null)return 0;switch(t.type){case"point":return e+10+8+24;case"polyline":case"polygon":{let s=0;const i=2+(t.hasZ?1:0)+(t.hasM?1:0),n=t.type==="polyline"?t.paths:t.rings;if((t.type==="polyline"?t.curvePaths:t.curveRings)?.length){const o=3*f()*128;s=8*o*i+128*o+32*(n.length+1)}else s=c(n);return e+64+s+34}case"multipoint":{const s=c(t.points);return e+s+64+34+32}case"extent":return e+10+64+34;case"mesh":{const s=t.vertexAttributes;return e+h(s.position,s.normal,s.uv,s.tangent)}default:return e}}function M(t,s){switch(m(s),t.type==="mesh"&&(t=t.extent),t.type){case"point":s[0]=s[3]=t.x,s[1]=s[4]=t.y,t.hasZ&&(s[2]=s[5]=t.z);break;case"polyline":for(let i=0;i<t.paths.length;i++)l(s,t.paths[i],!!t.hasZ);break;case"polygon":for(let i=0;i<t.rings.length;i++)l(s,t.rings[i],!!t.hasZ);break;case"multipoint":l(s,t.points,!!t.hasZ);break;case"extent":s[0]=t.xmin,s[1]=t.ymin,s[3]=t.xmax,s[4]=t.ymax,t.zmin!=null&&(s[2]=t.zmin),t.zmax!=null&&(s[5]=t.zmax)}return s}function P(t,s){switch(p(s),t.type==="mesh"&&(t=t.extent),t.type){case"point":s[0]=s[2]=t.x,s[1]=s[3]=t.y;break;case"polyline":for(let i=0;i<t.paths.length;i++)u(s,t.paths[i]);break;case"polygon":for(let i=0;i<t.rings.length;i++)u(s,t.rings[i]);break;case"multipoint":u(s,t.points);break;case"extent":s[0]=t.xmin,s[1]=t.ymin,s[2]=t.xmax,s[3]=t.ymax}}function T(t,s){return t.objectId!=null?t.objectId:t.attributes&&s?t.attributes[s]:null}function q(t,s,i,n){if(s?.size&&i!=null&&t)for(const r in t){if(!s.has(r))continue;const o=t[r];typeof o=="string"&&o.length>i&&(n(r),t[r]="")}}export{R as F,T as R,N as b,F as d,f as e,j as i,I as n,w as t,M as v,q as w,$ as x,P as z};
