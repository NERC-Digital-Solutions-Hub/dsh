import{bS as U,H as C,I as V,aH as A,y as W,i as _,J as B,bV as z,a4 as E}from"./-Rap9rN9.js";import{y as F,P as J}from"./Buev1GnW.js";import{o as q,r as L,i as b,s as H}from"./BuuPbopx.js";import{v as X,f as G}from"./Do8kswpP.js";import{f as K}from"./-1lFHQHv.js";import{r as Q,o as Y}from"./BIgXkzOy.js";async function Z(e,n,l,s){const t=K(e),i=n[0].spatialReference,r={...s,responseType:"json",query:{...t.query,f:"json",sr:U(i),target:JSON.stringify({geometryType:X(n[0]),geometries:n}),cutter:JSON.stringify(l)}},o=await C(t.path+"/cut",r),{cutIndexes:f,geometries:c=[]}=o.data;return{cutIndexes:f,geometries:c.map((u=>{const m=G(u);return m.spatialReference=i,m}))}}async function ee(e,n,l){const s=typeof e=="string"?V(e):e,t=n[0].spatialReference,i=X(n[0]),r={...l,query:{...s.query,f:"json",sr:U(t),geometries:JSON.stringify(Q(n))}},{data:o}=await C(s.path+"/simplify",r);return Y(o.geometries,i,t)}const D=()=>_.getLogger("esri.geometry.support.normalizeUtils");function te(e){return e.type==="polygon"}function ne(e){return e[0].type==="polygon"}function se(e){return e[0].type==="polyline"}function k(e){const n=[];let l=0,s=0;for(let t=0;t<e.length;t++){const i=e[t];let r=null;for(let o=0;o<i.length;o++)r=i[o],n.push(r),o===0?(l=r[0],s=l):(l=Math.min(l,r[0]),s=Math.max(s,r[0]));r&&n.push([(l+s)/2,0])}return n}function oe(e,n){if(!(e instanceof F||e instanceof J)){const t="straightLineDensify: the input geometry is neither polyline nor polygon";throw D().error(t),new W("internal:geometry",t)}const l=q(e),s=[];for(const t of l){const i=[];s.push(i),i.push([t[0][0],t[0][1]]);for(let r=0;r<t.length-1;r++){const o=t[r][0],f=t[r][1],c=t[r+1][0],u=t[r+1][1],m=Math.sqrt((c-o)*(c-o)+(u-f)*(u-f)),p=(u-f)/m,d=(c-o)/m,g=m/n;if(g>1){for(let R=1;R<=g-1;R++){const v=R*n,a=d*v+o,h=p*v+f;i.push([a,h])}const w=(m+Math.floor(g-1)*n)/2,P=d*w+o,I=p*w+f;i.push([P,I])}i.push([c,u])}}return te(e)?new J({rings:s,spatialReference:e.spatialReference}):new F({paths:s,spatialReference:e.spatialReference})}function O(e,n,l){if(n){const s=oe(e,1e6);e=E(s,!0)}return l&&(e=H(e,l)),e}function T(e,n,l){if(Array.isArray(e)){const s=e[0];if(s>n){const t=b(s,n);e[0]=s+t*(-2*n)}else if(s<l){const t=b(s,l);e[0]=s+t*(-2*l)}}else{const s=e.x;if(s>n){const t=b(s,n);e=e.clone().offset(t*(-2*n),0)}else if(s<l){const t=b(s,l);e=e.clone().offset(t*(-2*l),0)}}return e}function re(e,n){let l=-1;for(let s=0;s<n.cutIndexes.length;s++){const t=n.cutIndexes[s],i=n.geometries[s],r=q(i);for(let o=0;o<r.length;o++){const f=r[o];f.some((c=>{if(c[0]<180)return!0;{let u=0;for(let p=0;p<f.length;p++){const d=f[p][0];u=d>u?d:u}u=Number(u.toFixed(9));const m=-360*b(u,180);for(let p=0;p<f.length;p++){const d=i.getPoint(o,p);i.setPoint(o,p,d.clone().offset(m,0))}return!0}}))}if(t===l){if(ne(e))for(const o of q(i))e[t]=e[t].addRing(o);else if(se(e))for(const o of q(i))e[t]=e[t].addPath(o)}else l=t,e[t]=i}return e}async function ie(e,n,l){if(!Array.isArray(e))return ie([e],n);n&&typeof n!="string"&&D().warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const s=typeof n=="string"?n:n?.url??B.geometryServiceUrl;let t,i,r,o,f,c,u,m,p=0;const d=[],g=[];for(const a of e)if(a!=null)if(t||(t=a.spatialReference,i=A(t),r=t.isWebMercator,c=r?102100:4326,o=L[c].maxX,f=L[c].minX,u=L[c].plus180Line,m=L[c].minus180Line),i)if(a.type==="mesh")g.push(a);else if(a.type==="point")g.push(T(a.clone(),o,f));else if(a.type==="multipoint"){const h=a.clone();h.points=h.points.map((x=>T(x,o,f))),g.push(h)}else if(a.type==="extent"){const h=a.clone()._normalize(!1,!1,i);g.push(h.rings?new J(h):h)}else if(a.extent){const h=a.extent,x=b(h.xmin,f)*(2*o);let M=x===0?a.clone():H(a.clone(),x);h.offset(x,0);let{xmin:$,xmax:y}=h;$=Number($.toFixed(9)),y=Number(y.toFixed(9)),h.intersects(u)&&y!==o?(p=y>p?y:p,M=O(M,r),d.push(M),g.push("cut")):h.intersects(m)&&$!==f?(p=y*(2*o)>p?y*(2*o):p,M=O(M,r,360),d.push(M),g.push("cut")):g.push(M)}else g.push(a.clone());else g.push(a);else g.push(a);let w=b(p,o),P=-90;const I=w,R=new F;for(;w>0;){const a=360*w-180;R.addPath([[a,P],[a,-1*P]]),P*=-1,w--}if(d.length>0&&I>0){const a=re(d,await Z(s,d,R,l)),h=[],x=[];for(let y=0;y<g.length;y++){const N=g[y];if(N!=="cut")x.push(N);else{const j=a.shift(),S=e[y];S!=null&&S.type==="polygon"&&S.rings&&S.rings.length>1&&j.rings.length>=S.rings.length?(h.push(j),x.push("simplify")):x.push(r?z(j):j)}}if(!h.length)return x;const M=await ee(s,h,l),$=[];for(let y=0;y<x.length;y++){const N=x[y];N!=="simplify"?$.push(N):$.push(r?z(M.shift()):M.shift())}return $}const v=[];for(let a=0;a<g.length;a++){const h=g[a];if(h!=="cut")v.push(h);else{const x=d.shift();v.push(r===!0?z(x):x)}}return v}function he(e){if(!e)return null;const n=e.extent;if(!n)return null;const l=e.spatialReference&&A(e.spatialReference);if(!l)return n;const[s,t]=l.valid,i=2*t,{width:r}=n;let o,{xmin:f,xmax:c}=n;if([f,c]=[c,f],e.type==="extent"||r===0||r<=t||r>i||f<s||c>t)return n;switch(e.type){case"polygon":if(!(e.rings.length>1))return n;o=k(e.rings);break;case"polyline":if(!(e.paths.length>1))return n;o=k(e.paths);break;case"multipoint":o=e.points}const u=n.clone();for(let m=0;m<o.length;m++){let p=o[m][0];p<0?(p+=t,c=Math.max(p,c)):(p-=t,f=Math.min(p,f))}return u.xmin=f,u.xmax=c,u.width<r?(u.xmin-=t,u.xmax-=t,u):n}function ge(e,n,l){const s=A(l);if(s==null)return e;const[t,i]=s.valid,r=2*i;let o=0,f=0;n>i?o=Math.ceil(Math.abs(n-i)/r):n<t&&(o=-Math.ceil(Math.abs(n-t)/r)),e>i?f=Math.ceil(Math.abs(e-i)/r):e<t&&(f=-Math.ceil(Math.abs(e-t)/r));let c=e+(o-f)*r;const u=c-n;return u>i?c-=r:u<t&&(c+=r),c}function me(e,n){const l=A(n);if(l){const[s,t]=l.valid,i=t-s;if(e<s)for(;e<s;)e+=i;if(e>t)for(;e>t;)e-=i}return e}export{me as L,oe as M,ge as P,ie as R,he as v};
