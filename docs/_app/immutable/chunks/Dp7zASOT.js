import{_ as S,a as v}from"./Vj4mvAVU.js";import"./C9_KfL0q.js";import"./BzZgUCJc.js";import{f as D,d as E}from"./BX3KUzk8.js";import{ai as y,aj as z,ak as $}from"./ftSj4mLm.js";import"./2lNp6ocP.js";import{n as j}from"./B87vTgcy.js";function k(e,r,t){const{extent:a,valid:u}=e,[n,o,i,s]=a;return!(t<o||t>s)&&(u!=null&&n>i?r>=i||r<=n:r>=n&&r<=i)}function T(e,r,t,a){const{extent:u,modelSize:n,valid:o}=e,[i,s,c]=u,f=b(i,c,o);let l=r/n[0]*f+i;return o!=null&&a&&(l=new j(o[0],o[1]).normalize(l)),[l,(n[1]-t)/n[1]*y(u)+s]}function b(e,r,t){if(t!=null&&e>r){const[a,u]=t;return u-e+(r-a)}return r-e}function A(e){return e?4:3}function F(e,r,t){const[a,u]=t.modelSize;let n=null;const o=new Map;r.forEach(s=>{o.set(s.lij,D(e,s))});const i=(s,c,f)=>z(s.extent,c,f);return(s,c)=>{const f=Math.round(s),l=Math.round(c);if(!e.wrapAround&&(f<0||f>=a||l<0||l>=u))return[0,0];const[d,m]=T(t,s,c,!0);if(!k(t,d,m))return[0,0];if(n==null||!i(n,d,m)){n=null;for(const[I,x]of r)if(i(x,d,m)){n=x;break}}if(n?.data==null)return[0,0];const g=o.get(n.lij);if(g==null)return[0,0];const{width:M,height:w,extent:p}=n;return g((d-p[0])/$(p)*M,w-(m-p[1])/y(p)*w)}}let h=class{constructor(){this._tileData=new Map}async generateStreamlines(e){const{flowData:r,flowExtentInfo:t,needsMagnitude:a,simulationSettings:u,startPositions:n}=e,o=_(D(u,r),u,t.modelSize,a,n);return{result:{streamlines:o},transferList:o?.map(i=>i.vertices.buffer)}}async generateTiledStreamlines(e){const{flowDataTiles:r,flowExtentInfo:t,needsMagnitude:a,reset:u,simulationSettings:n,startPositions:o}=e;this._updateTileData(r,u);const i=_(F(n,this._tileData,t),n,t.modelSize,a,o);return{result:{streamlines:i},transferList:i?.map(s=>s.vertices.buffer)??[]}}_updateTileData(e,r){r&&this._tileData.forEach((t,a)=>{e.get(a)==null&&this._tileData.delete(a)}),e.forEach((t,a)=>{t.type==="delete"?this._tileData.delete(a):t.type!=="on-worker"&&t.type!=="waiting"&&this._tileData.set(a,t.data)})}};h=S([v("esri.views.3d.support.flow.FlowWorker")],h);const H=h;function _(e,r,t,a,u){if(e==null)return;const n=E(r,e,t[0],t[1],{positions:u}),o=[],i=A(a);for(const{vertices:s,stage:c}of n){const f=new Float32Array(s.length*i);for(let l=0;l<s.length;l++)f[l*i]=s[l].x,f[l*i+1]=s[l].y,f[l*i+2]=s[l].t,a&&(f[l*i+3]=s[l].speed);o.push({vertices:f,stage:c,hasMagnitude:a})}return o}export{H as default};
