import{s as _}from"./BFGjv385.js";import{n as B}from"./B87vTgcy.js";import{i as E,s as K}from"./DSdBzmdi.js";import{y as F,P as U}from"./CttKhsFI.js";import{A as k,G as L,f as C}from"./DsdqSOQR.js";import{r as P,i as b,o as z,s as G}from"./4rLBhf07.js";import{j as I,S as Q}from"./8d4XiCAe.js";import{H}from"./BJhaCM43.js";import{v as X,f as V}from"./CISVLUtc.js";import{f as Y}from"./COehenBl.js";import{I as Z}from"./DzPnzJx5.js";import{r as ee,o as te}from"./DdWc1Xci.js";async function ne(e,t,i,r){const n=Y(e),l=t[0].spatialReference,o={...r,responseType:"json",query:{...n.query,f:"json",sr:k(l),target:JSON.stringify({geometryType:X(t[0]),geometries:t}),cutter:JSON.stringify(i)}},s=await H(n.path+"/cut",o),{cutIndexes:f,geometries:a=[]}=s.data;return{cutIndexes:f,geometries:a.map(u=>{const g=V(u);return g.spatialReference=l,g})}}async function se(e,t,i){const r=typeof e=="string"?Z(e):e,n=t[0].spatialReference,l=X(t[0]),o={...i,query:{...r.query,f:"json",sr:k(n),geometries:JSON.stringify(ee(t))}},{data:s}=await H(r.path+"/simplify",o);return te(s.geometries,l,n)}const D=()=>E.getLogger("esri.geometry.support.normalizeUtils");function re(e){return e.type==="polygon"}function oe(e){return e[0].type==="polygon"}function ie(e){return e[0].type==="polyline"}function J(e){const t=[];let i=0,r=0;for(let n=0;n<e.length;n++){const l=e[n];let o=null;for(let s=0;s<l.length;s++)o=l[s],t.push(o),s===0?(i=o[0],r=i):(i=Math.min(i,o[0]),r=Math.max(r,o[0]));o&&t.push([(i+r)/2,0])}return t}function le(e,t){if(!(e instanceof F||e instanceof U)){const n="straightLineDensify: the input geometry is neither polyline nor polygon";throw D().error(n),new K("internal:geometry",n)}const i=z(e),r=[];for(const n of i){const l=[];r.push(l),l.push([n[0][0],n[0][1]]);for(let o=0;o<n.length-1;o++){const s=n[o][0],f=n[o][1],a=n[o+1][0],u=n[o+1][1],g=Math.sqrt((a-s)*(a-s)+(u-f)*(u-f)),p=(u-f)/g,d=(a-s)/g,m=g/t;if(m>1){for(let R=1;R<=m-1;R++){const S=R*t,c=d*S+s,h=p*S+f;l.push([c,h])}const $=(g+Math.floor(m-1)*t)/2,A=d*$+s,q=p*$+f;l.push([A,q])}l.push([a,u])}}return re(e)?new U({rings:r,spatialReference:e.spatialReference}):new F({paths:r,spatialReference:e.spatialReference})}function O(e,t,i){if(t){const r=le(e,1e6);e=Q(r,!0)}return i&&(e=G(e,i)),e}function T(e,t,i){if(Array.isArray(e)){const r=e[0];if(r>t){const n=b(r,t);e[0]=r+n*(-2*t)}else if(r<i){const n=b(r,i);e[0]=r+n*(-2*i)}}else{const r=e.x;if(r>t){const n=b(r,t);e=e.clone().offset(n*(-2*t),0)}else if(r<i){const n=b(r,i);e=e.clone().offset(n*(-2*i),0)}}return e}function fe(e,t){let i=-1;for(let r=0;r<t.cutIndexes.length;r++){const n=t.cutIndexes[r],l=t.geometries[r],o=z(l);for(let s=0;s<o.length;s++){const f=o[s];f.some(a=>{if(a[0]<180)return!0;{let u=0;for(let p=0;p<f.length;p++){const d=f[p][0];u=d>u?d:u}u=Number(u.toFixed(9));const g=-360*b(u,180);for(let p=0;p<f.length;p++){const d=l.getPoint(s,p);l.setPoint(s,p,d.clone().offset(g,0))}return!0}})}if(n===i){if(oe(e))for(const s of z(l))e[n]=e[n].addRing(s);else if(ie(e))for(const s of z(l))e[n]=e[n].addPath(s)}else i=n,e[n]=l}return e}async function ce(e,t,i){if(!Array.isArray(e))return ce([e],t);t&&typeof t!="string"&&D().warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const r=typeof t=="string"?t:t?.url??_.geometryServiceUrl;let n,l,o,s,f,a,u,g,p=0;const d=[],m=[];for(const c of e)if(c!=null)if(n||(n=c.spatialReference,l=L(n),o=n.isWebMercator,a=o?102100:4326,s=P[a].maxX,f=P[a].minX,u=P[a].plus180Line,g=P[a].minus180Line),l)if(c.type==="mesh")m.push(c);else if(c.type==="point")m.push(T(c.clone(),s,f));else if(c.type==="multipoint"){const h=c.clone();h.points=h.points.map(x=>T(x,s,f)),m.push(h)}else if(c.type==="extent"){const h=c.clone()._normalize(!1,!1,l);m.push(h.rings?new U(h):h)}else if(c.extent){const h=c.extent,x=b(h.xmin,f)*(2*s);let M=x===0?c.clone():G(c.clone(),x);h.offset(x,0);let{xmin:w,xmax:y}=h;w=Number(w.toFixed(9)),y=Number(y.toFixed(9)),h.intersects(u)&&y!==s?(p=y>p?y:p,M=O(M,o),d.push(M),m.push("cut")):h.intersects(g)&&w!==f?(p=y*(2*s)>p?y*(2*s):p,M=O(M,o,360),d.push(M),m.push("cut")):m.push(M)}else m.push(c.clone());else m.push(c);else m.push(c);let $=b(p,s),A=-90;const q=$,R=new F;for(;$>0;){const c=360*$-180;R.addPath([[c,A],[c,-1*A]]),A*=-1,$--}if(d.length>0&&q>0){const c=fe(d,await ne(r,d,R,i)),h=[],x=[];for(let y=0;y<m.length;y++){const j=m[y];if(j!=="cut")x.push(j);else{const N=c.shift(),v=e[y];v!=null&&v.type==="polygon"&&v.rings&&v.rings.length>1&&N.rings.length>=v.rings.length?(h.push(N),x.push("simplify")):x.push(o?I(N):N)}}if(!h.length)return x;const M=await se(r,h,i),w=[];for(let y=0;y<x.length;y++){const j=x[y];j!=="simplify"?w.push(j):w.push(o?I(M.shift()):M.shift())}return w}const S=[];for(let c=0;c<m.length;c++){const h=m[c];if(h!=="cut")S.push(h);else{const x=d.shift();S.push(o===!0?I(x):x)}}return S}function be(e){if(!e)return null;const t=e.extent;if(!t)return null;const i=e.spatialReference&&L(e.spatialReference);if(!i)return t;const[r,n]=i.valid,l=2*n,{width:o}=t;let s,{xmin:f,xmax:a}=t;if([f,a]=[a,f],e.type==="extent"||o===0||o<=n||o>l||f<r||a>n)return t;switch(e.type){case"polygon":if(!(e.rings.length>1))return t;s=J(e.rings);break;case"polyline":if(!(e.paths.length>1))return t;s=J(e.paths);break;case"multipoint":s=e.points}const u=t.clone();for(let g=0;g<s.length;g++){let p=s[g][0];p<0?(p+=n,a=Math.max(p,a)):(p-=n,f=Math.min(p,f))}return u.xmin=f,u.xmax=a,u.width<o?(u.xmin-=n,u.xmax-=n,u):t}function Re(e,t,i){const r=L(i);if(r==null)return e;const[n,l]=r.valid,o=2*l;let s=0,f=0;t>l?s=Math.ceil(Math.abs(t-l)/o):t<n&&(s=-Math.ceil(Math.abs(t-n)/o)),e>l?f=Math.ceil(Math.abs(e-l)/o):e<n&&(f=-Math.ceil(Math.abs(e-n)/o));let a=e+(s-f)*o;const u=a-t;return u>l?a-=o:u<n&&(a+=o),a}function Se(e,t){return W(t)?.normalize(e)??e}function W(e){const t=L(e);if(t==null)return null;const[i,r]=t.valid;return new B(i,r)}const Ae=W(C.WGS84);W(C.WebMercator);export{Ae as A,Re as L,ce as P,Se as S,le as b,be as z};
