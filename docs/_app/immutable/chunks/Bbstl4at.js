import{l as T,r as n,m as o,a as g,bk as q,f as R,o as x}from"./BNOt8YR4.js";import{l as Y,U as Z}from"./CJiRSAJW.js";import{f as d,j as B,i as ee,s as te,m as O}from"./Rwg6dtTd.js";import{a as re}from"./DXt7o69B.js";import{a as ie}from"./C5CzMsLd.js";import{t as S,c as M}from"./Cql9WcjV.js";import{q as U}from"./C2DcqfsJ.js";import{o as m}from"./aQeO9QTD.js";import{r as G}from"./n1aeND0Y.js";import{p as J,l as D}from"./CB03HcVi.js";import{t as H,A as K}from"./Dd7EA3gn.js";import{o as _}from"./CWBpglYE.js";import{m as P}from"./CEpAi7IA.js";import{m as j}from"./Buh8yAuW.js";import{p as se}from"./ivb9LPrj.js";import{g as ne,f as oe,l as E}from"./DXJjtRC1.js";import{x as Q}from"./MtSiOt06.js";import{u as le}from"./DqjwRB0b.js";let f=class extends re.ClonableMixin(T){constructor(s){super(s),this.expression=null,this.title=null,this.returnType=null}};n([o({type:String,json:{write:!0}})],f.prototype,"expression",void 0),n([o({type:String,json:{write:!0}})],f.prototype,"title",void 0),n([o({type:String,json:{write:!0}})],f.prototype,"returnType",void 0),f=n([g("esri.layers.support.ExpressionInfo")],f);var F,v;let p=(v=class extends T{constructor(s){super(s),this.isAutoGenerated=!1,this.name=null,this.alias=null,this.onStatisticField=null,this.onStatisticExpression=null,this.statisticType=null}clone(){return new F({name:this.name,alias:this.alias,isAutoGenerated:this.isAutoGenerated,onStatisticExpression:d(this.onStatisticExpression),onStatisticField:this.onStatisticField,statisticType:this.statisticType})}},F=v,v);n([o({type:Boolean,json:{write:!0}})],p.prototype,"isAutoGenerated",void 0),n([o({type:String,json:{write:!0}})],p.prototype,"name",void 0),n([o({type:String,json:{write:!0}})],p.prototype,"alias",void 0),n([o({type:String,json:{write:!0}})],p.prototype,"onStatisticField",void 0),n([o({type:f,json:{write:!0}})],p.prototype,"onStatisticExpression",void 0),n([o({type:String,json:{write:!0}})],p.prototype,"statisticType",void 0),p=F=n([g("esri.layers.support.AggregateField")],p);var V;let u=V=class extends S{constructor(r){super(r),this.type="binning",this.binType="geohash",this.fixedBinLevel=null,this.labelingInfo=null,this.labelsVisible=!0,this.maxScale=0,this.popupEnabled=!0,this.popupTemplate=null,this.size=m("12px"),this.fields=[],this.renderer=null}writeFields(r,s,e){const t=r.filter((i=>i.statisticType!=="avg_angle")).map((i=>i.toJSON()));B(e,t,s)}readRenderer(r,s,e){const t=s.drawingInfo?.renderer;return t?_(t,s,e)??void 0:H(s,e)}clone(){return new V({fields:d(this.fields),fixedBinLevel:this.fixedBinLevel,labelingInfo:d(this.labelingInfo),labelsVisible:this.labelsVisible,maxScale:this.maxScale,popupEnabled:this.popupEnabled,popupTemplate:d(this.popupTemplate),renderer:d(this.renderer),binType:d(this.binType),size:this.size})}};n([G({binning:"binning"})],u.prototype,"type",void 0),n([G({geohash:"geohash",square:"square"}),o({type:["geohash","square"]})],u.prototype,"binType",void 0),n([o({type:Number,json:{write:!0}})],u.prototype,"fixedBinLevel",void 0),n([o({type:[K],json:{read:{source:"drawingInfo.labelingInfo"},write:{target:"drawingInfo.labelingInfo"}}})],u.prototype,"labelingInfo",void 0),n([o(J)],u.prototype,"labelsVisible",void 0),n([o({type:Number,json:{default:0,name:"visibilityInfo.maxScale"}})],u.prototype,"maxScale",void 0),n([o(D)],u.prototype,"popupEnabled",void 0),n([o({type:U,json:{name:"popupInfo",write:!0}})],u.prototype,"popupTemplate",void 0),n([o({cast:r=>r==="auto"?r:q(m(r))})],u.prototype,"size",void 0),n([o({type:[p],json:{write:!0}})],u.prototype,"fields",void 0),n([R("fields")],u.prototype,"writeFields",null),n([o({types:P,json:{write:{target:"drawingInfo.renderer"}}})],u.prototype,"renderer",void 0),n([x("renderer",["drawingInfo.renderer"])],u.prototype,"readRenderer",null),u=V=n([g("esri.layers.support.FeatureReductionBinning")],u);var z;function k(r){return r.type==="simple"&&!r.visualVariables?.length}let a=z=class extends T{constructor(r){super(r),this.type="cluster",this.clusterRadius=m("80px"),this.clusterMinSize=m("12px"),this.clusterMaxSize=m("50px"),this.maxScale=0,this.popupEnabled=!0,this.popupTemplate=null,this.renderer=null,this.symbol=null,this.labelingInfo=null,this.labelsVisible=!0,this.fields=[]}readRenderer(r,s,e){const t=s.drawingInfo?.renderer;return t?.authoringInfo?.isAutoGenerated?null:t?k(t)?null:_(t,s,e)??void 0:H(s,e)}readSymbol(r,s,e){const t=s.drawingInfo?.renderer;return t?.authoringInfo?.isAutoGenerated?null:t&&k(t)?_(t,s,e)?.symbol:null}writeSymbol(r,s,e,t){const i=this.renderer?.authoringInfo?.isAutoGenerated;if(!this.renderer||i){const l=new j({symbol:r});s.drawingInfo={renderer:l.write({},t)}}}writeFields(r,s,e){const t=r.filter((i=>i.statisticType!=="avg_angle")).map((i=>i.toJSON()));B(e,t,s)}readFields(r,s,e){return r.filter((t=>!t.isAutoGenerated)).map((t=>p.fromJSON(t)))}clone(){return new z({clusterRadius:this.clusterRadius,clusterMinSize:this.clusterMinSize,clusterMaxSize:this.clusterMaxSize,labelingInfo:d(this.labelingInfo),labelsVisible:this.labelsVisible,fields:d(this.fields),maxScale:this.maxScale,renderer:d(this.renderer),symbol:d(this.symbol),popupEnabled:this.popupEnabled,popupTemplate:d(this.popupTemplate)})}};n([o({type:["cluster"],readOnly:!0,json:{write:!0}})],a.prototype,"type",void 0),n([o({cast:r=>r==="auto"?r:q(m(r)),json:{write:!0}})],a.prototype,"clusterRadius",void 0),n([o({type:Number,cast:m,json:{write:!0}})],a.prototype,"clusterMinSize",void 0),n([o({type:Number,cast:m,json:{write:!0}})],a.prototype,"clusterMaxSize",void 0),n([o({type:Number,json:{default:0,name:"visibilityInfo.maxScale"}})],a.prototype,"maxScale",void 0),n([o(D)],a.prototype,"popupEnabled",void 0),n([o({type:U,json:{read:{source:"popupInfo"},write:{target:"popupInfo"}}})],a.prototype,"popupTemplate",void 0),n([o({types:P,json:{write:{target:"drawingInfo.renderer"}}})],a.prototype,"renderer",void 0),n([x("renderer",["drawingInfo.renderer"])],a.prototype,"readRenderer",null),n([o({types:se})],a.prototype,"symbol",void 0),n([x("symbol",["drawingInfo.renderer"])],a.prototype,"readSymbol",null),n([R("symbol")],a.prototype,"writeSymbol",null),n([o({type:[K],json:{read:{source:"drawingInfo.labelingInfo"},write:{target:"drawingInfo.labelingInfo"}}})],a.prototype,"labelingInfo",void 0),n([o(J)],a.prototype,"labelsVisible",void 0),n([o({type:[p],json:{write:!0}})],a.prototype,"fields",void 0),n([R("fields")],a.prototype,"writeFields",null),n([x("fields")],a.prototype,"readFields",null),a=z=n([g("esri.layers.support.FeatureReductionCluster")],a);const N={key:"type",base:S,typeMap:{cluster:a,binning:u}},ae={types:{key:"type",base:S,typeMap:{selection:M,cluster:a,binning:u}},json:{name:"layerDefinition.featureReduction",write:{allowNull:!0},origins:{"web-map":{types:N},"portal-item":{types:N},"web-scene":{types:{key:"type",base:S,typeMap:{selection:M}},name:"layerDefinition.featureReduction",write:{layerContainerTypes:ie}}}}},ue=()=>ee.getLogger("esri.views.2d.layers.support.clusterUtils");O.add("esri-cluster-arcade-enabled",!0);const pe=O("esri-cluster-arcade-enabled"),de=new Set(["simple-line","simple-fill","picture-fill"]);function L(r,s){let e=s.clone();if(!ce(e))return e;if(s.symbols.some((t=>de.has(t.type)))&&(e=new j({symbol:new le})),e.authoringInfo||(e.authoringInfo=new ne),e.authoringInfo.isAutoGenerated=!0,"visualVariables"in e){const t=(e.visualVariables||[]).filter((i=>i.valueExpression!=="$view.scale"));t.forEach((i=>{i.type==="rotation"?i.field?i.field=y(r,i.field,"avg_angle","number"):i.valueExpression&&(i.field=h(r,i.valueExpression,"avg_angle","number"),i.valueExpression=null):i.normalizationField?(i.field=y(r,i.field,"avg_norm","number",i.normalizationField),i.normalizationField=null):i.field?i.field=y(r,i.field,"avg","number"):i.valueExpression&&(i.field=h(r,i.valueExpression,"avg","number"),i.valueExpression=null)})),e.visualVariables=t}switch(e.type){case"simple":break;case"pie-chart":for(const t of e.attributes)t.field?t.field=y(r,t.field,"sum","number"):t.valueExpression&&(t.field=h(r,t.valueExpression,"sum","number"),t.valueExpression=null);break;case"unique-value":e.field?e.field=y(r,e.field,"mode","string"):e.valueExpression&&(e.field=h(r,e.valueExpression,"mode","string"),e.valueExpression=null);break;case"class-breaks":e.normalizationField?(e.field=y(r,e.field,"avg_norm","number",e.normalizationField),e.normalizationField=null):e.field?e.field=y(r,e.field,"avg","number"):e.valueExpression&&(e.field=h(r,e.valueExpression,"avg","number"),e.valueExpression=null)}return e}const ce=r=>{const s=e=>ue().error(new te("Unsupported-renderer",e,{renderer:r}));if(!r)return!1;switch(r.type){case"unique-value":if(r.field2||r.field3)return s("FeatureReductionCluster does not support multi-field UniqueValueRenderers"),!1;break;case"class-breaks":if(r.normalizationField){const e=r.normalizationType;if(e!=="field")return s(`FeatureReductionCluster does not support a normalizationType of ${e}`),!1}break;case"simple":case"pie-chart":break;default:return s(`FeatureReductionCluster does not support renderers of type ${r.type}`),!1}if(!pe){if("valueExpression"in r&&r.valueExpression)return s("FeatureReductionCluster does not currently support renderer.valueExpression. Support will be added in a future release"),!1;if(("visualVariables"in r&&r.visualVariables||[]).some((e=>!(!("valueExpression"in e)||!e.valueExpression))))return s("FeatureReductionCluster does not currently support visualVariables with a valueExpression. Support will be added in a future release"),!1}return!0};function fe(r,s,e){switch(r){case"sum":return`cluster_sum_${s}`;case"avg":case"avg_angle":return`cluster_avg_${s}`;case"mode":return`cluster_type_${s}`;case"avg_norm":{const t=e,i="field",l=s.toLowerCase()+",norm:"+i+","+t.toLowerCase();return"cluster_avg_"+Q(l)}}}function h(r,s,e,t){const i=Q(s),l=e==="mode"?`cluster_type_${i}`:e==="sum"?`cluster_sum_${i}`:`cluster_avg_${i}`;return r.some((c=>c.name===l))||r.push(new p({name:l,isAutoGenerated:!0,onStatisticExpression:new f({expression:s,returnType:t}),statisticType:e})),l}function y(r,s,e,t,i){if(s==="cluster_count"||r.some((c=>c.name===s)))return s;const l=fe(e,s,i);return r.some((c=>c.name===l))||(e==="avg_norm"?r.push(new p({name:l,isAutoGenerated:!0,onStatisticExpression:new f({expression:`$feature.${s} / $feature.${i}`,returnType:t}),statisticType:"avg"})):r.push(new p({name:l,isAutoGenerated:!0,onStatisticField:s,statisticType:e}))),l}const Ce=r=>{let s=class extends r{constructor(...e){super(...e),this.addHandles(Y((()=>this.renderer),(()=>{if(this.featureReduction){const t=this._normalizeFeatureReduction(this.featureReduction);this._set("featureReduction",t)}}),Z))}set featureReduction(e){const t=this._normalizeFeatureReduction(e);this._set("featureReduction",t)}set renderer(e){}_withClusterVariable(e,t,i){const l=e.clone();return"visualVariables"in l&&(l.visualVariables||(l.visualVariables=[]),l.visualVariables.some((c=>c.type==="size"))||l.visualVariables.push(new oe({field:"cluster_count",stops:[new E({value:1}),new E({useMinValue:!0,size:t}),new E({useMaxValue:!0,size:i})]}))),l}_normalizeFeatureReduction(e){if(e?.type!=="cluster")return e;const t=e.clone(),i=[new p({name:"cluster_count",alias:"cluster_count",isAutoGenerated:!0,statisticType:"count"})],l=(t.fields??[]).filter((b=>!b.isAutoGenerated)),c=e.renderer&&!e.renderer.authoringInfo?.isAutoGenerated,{clusterMinSize:$,clusterMaxSize:I}=t;if(c){t.fields=[...i,...l];const b=this._withClusterVariable(t.renderer,$,I);return t.effectiveFeatureRenderer=b,t.effectiveClusterRenderer=b,t}if(e.symbol){if(t.fields=[...i,...l],t.renderer=null,!this.renderer)return t.effectiveFeatureRenderer=null,t.effectiveClusterRenderer=null,t;const b=L(i,this.renderer),w=this._withClusterVariable(b,$,I),W="visualVariables"in w&&w.visualVariables?w.visualVariables:[],X=new j({symbol:e.symbol,visualVariables:W});return t.fields=[...i,...l],t.effectiveFeatureRenderer=w,t.effectiveClusterRenderer=X,t}if(!this.renderer)return e;const C=L(i,this.renderer);t.fields=[...i,...l],t.renderer=C;const A=this._withClusterVariable(C,$,I);return t.effectiveFeatureRenderer=A,t.effectiveClusterRenderer=A,t}};return n([o(ae)],s.prototype,"featureReduction",null),s=n([g("esri.layers.mixins.FeatureReductionLayer")],s),s};export{Ce as d,p as n,ae as p};
