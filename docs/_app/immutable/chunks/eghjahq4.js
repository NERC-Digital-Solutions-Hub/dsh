import{c as z,_ as w,m as b,a as q}from"./ChMEnlEh.js";import{H as T}from"./DMOtirar.js";import{s as m}from"./BbNfuhIx.js";import{d as A,a as L,b as S,w as x,c as P}from"./B2reeZpr.js";import{y as C,a as M}from"./DUQhet5j.js";import{e as I}from"./DAgR0H0w.js";import{M as U,r as j}from"./D8DYOP_H.js";import{watch as k,initial as H}from"./Bvm6lAc7.js";import{A as R}from"./C44l9BTJ.js";import{e as F}from"./DmZVdEHX.js";import{i as N}from"./DCZICDHw.js";function E(t,e=!1){return t<=C?e?new Array(t).fill(0):new Array(t):new Uint32Array(t)}class g{constructor(e){K(e);const{location:i,data:a}=e;this.location=Object.freeze(M(i));const l=this.location.width,r=this.location.height;let s=!0,o=!0;const h=Math.ceil(l*r/32),n=E(h);let c=0;for(let f=0;f<a.length;f++){const u=f%32;a[f]?(o=!1,n[c]|=1<<u):s=!1,u===31&&++c}o?(this._availability="unavailable",this.byteSize=40):s?(this._availability="available",this.byteSize=40):(this._availability=n,this.byteSize=40+N(n))}getAvailability(e,i){if(this._availability==="unavailable"||this._availability==="available")return this._availability;const a=(e-this.location.top)*this.location.width+(i-this.location.left),l=a%32,r=a>>5,s=this._availability;return r<0||r>s.length?"unknown":s[r]&1<<l?"available":"unavailable"}static fromDefinition(e,i){const a=e.service.request||T,{row:l,col:r,width:s,height:o}=e,h={query:{f:"json"}};return i=i?{...h,...i}:h,a(J(e),i).then(n=>n.data).catch(n=>{if(n?.details?.httpStatus===422)return{location:{top:l,left:r,width:s,height:o},valid:!0,data:new Array(s*o).fill(0)};throw n}).then(n=>{if(n.location&&(n.location.top!==l||n.location.left!==r||n.location.width!==s||n.location.height!==o))throw new m("tilemap:location-mismatch","Tilemap response for different location than requested",{response:n,definition:{top:l,left:r,width:s,height:o}});return g.fromJSON(n)})}static fromJSON(e){return Object.freeze(new g(e))}}function D(t){return`${t.level}/${t.row}/${t.col}/${t.width}/${t.height}`}function J(t){let e;if(t.service.tileServers?.length){const a=t.service.tileServers;e=`${a&&a.length?a[t.row%a.length]:t.service.url}/tilemap/${t.level}/${t.row}/${t.col}/${t.width}/${t.height}`}else e=`${t.service.url}/tilemap/${t.level}/${t.row}/${t.col}/${t.width}/${t.height}`;const i=t.service.query;return i&&(e=`${e}?${i}`),e}function K(t){if(!t?.location)throw new m("tilemap:missing-location","Location missing from tilemap response");if(t.valid===!1)throw new m("tilemap:invalid","Tilemap response was marked as invalid");if(!t.data)throw new m("tilemap:missing-data","Data missing from tilemap response");if(!Array.isArray(t.data))throw new m("tilemap:data-mismatch","Data must be an array of numbers");if(t.data.length!==t.location.width*t.location.height)throw new m("tilemap:data-mismatch","Number of data items does not match width/height of tilemap")}var d;function O(t,e,i){return new m("tile-map:tile-unavailable","Tile is not available",{level:t,row:e,col:i})}var p;let v=(p=class extends z{constructor(e){super(e),this._pendingTilemapRequests={},this.request=T,this.size=32,this._prefetchingEnabled=!0}initialize(){this._tilemapCache=new I(2097152),this.addHandles(k(()=>{const{layer:e}=this;return[e?.parsedUrl,e?.tileServers,e?.apiKey,e?.customParameters]},()=>this._initializeTilemapDefinition(),H))}get effectiveMinLOD(){return this.minLOD??this.layer.tileInfo.lods[0].level}get effectiveMaxLOD(){return this.maxLOD??this.layer.tileInfo.lods[this.layer.tileInfo.lods.length-1].level}getAvailability(e,i,a){if(!this.layer.tileInfo.lodAt(e)||e<this.effectiveMinLOD||e>this.effectiveMaxLOD)return"unavailable";const l=this._tilemapFromCache(e,i,a,this._tmpTilemapDefinition);return l?l.getAvailability(i,a):"unknown"}fetchAvailability(e,i,a,l){return!this.layer.tileInfo.lodAt(e)||e<this.effectiveMinLOD||e>this.effectiveMaxLOD?Promise.reject(O(e,i,a)):this._fetchTilemap(e,i,a,l).catch(r=>r).then(r=>{if(r instanceof g){const s=r.getAvailability(i,a);if(s==="unavailable")throw O(e,i,a);return s}if(A(r))throw r;return"unknown"})}fetchAvailabilityUpsample(e,i,a,l,r){l.level=e,l.row=i,l.col=a;const s=this.layer.tileInfo;s.updateTileInfo(l);const o=this.fetchAvailability(e,i,a,r).catch(h=>{if(A(h))throw h;if(s.upsampleTile(l))return this.fetchAvailabilityUpsample(l.level,l.row,l.col,l,r);throw h});return this._fetchAvailabilityUpsamplePrefetch(e,i,a,r,o),o}async _fetchAvailabilityUpsamplePrefetch(e,i,a,l,r){if(!this._prefetchingEnabled)return;const s=`prefetch-${e}-${i}-${a}`;if(this.hasHandles(s))return;const o=new AbortController;r.then(()=>o.abort(),()=>o.abort());let h=!1;const n=L(()=>{h||(h=!0,o.abort())});if(this.addHandles(n,s),await U(10,o.signal).catch(()=>{}),h||(h=!0,this.removeHandles(s)),S(o))return;const c=new F(e,i,a),f={...l,signal:o.signal},u=this.layer.tileInfo;for(let y=0;d._prefetches.length<d._maxPrefetch&&u.upsampleTile(c);++y){const _=this.fetchAvailability(c.level,c.row,c.col,f);d._prefetches.push(_);const $=()=>{d._prefetches.removeUnordered(_)};_.then($,$)}}static cleanupTilemapCache(){this._prefetches.prune()}_fetchTilemap(e,i,a,l){if(!this.layer.tileInfo.lodAt(e)||e<this.effectiveMinLOD||e>this.effectiveMaxLOD)return Promise.reject(new m("tilemap-cache:level-unavailable",`Level ${e} is unavailable in the service`));const r=this._tmpTilemapDefinition,s=this._tilemapFromCache(e,i,a,r);if(s)return Promise.resolve(s);const o=l?.signal;return l={...l,signal:null},new Promise((h,n)=>{x(o,()=>n(P()));const c=D(r);let f=this._pendingTilemapRequests[c];if(!f){f=g.fromDefinition(r,l).then(y=>(this._tilemapCache.put(c,y,y.byteSize),y));const u=()=>{delete this._pendingTilemapRequests[c]};this._pendingTilemapRequests[c]=f,f.then(u,u)}f.then(h,n)})}_initializeTilemapDefinition(){if(!this.layer.parsedUrl)return;const{parsedUrl:e,apiKey:i,customParameters:a}=this.layer;this._tilemapCache.clear(),this._tmpTilemapDefinition={service:{url:e.path,query:R({...e.query,...a,token:i??e.query?.token}),tileServers:this.layer.tileServers,request:this.request},width:this.size,height:this.size,level:0,row:0,col:0}}_tilemapFromCache(e,i,a,l){l.level=e,l.row=i-i%this.size,l.col=a-a%this.size;const r=D(l);return this._tilemapCache.get(r)}get test(){}},d=p,p._maxPrefetch=4,p._prefetches=new j({initialSize:d._maxPrefetch}),p);w([b({constructOnly:!0})],v.prototype,"layer",void 0),w([b({constructOnly:!0})],v.prototype,"minLOD",void 0),w([b({constructOnly:!0})],v.prototype,"maxLOD",void 0),w([b({constructOnly:!0})],v.prototype,"request",void 0),w([b({constructOnly:!0})],v.prototype,"size",void 0),v=d=w([q("esri.layers.support.TilemapCache")],v);export{v as j};
