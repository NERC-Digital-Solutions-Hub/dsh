import{h as T}from"./DwWpeHsS.js";import{M as Z}from"./bnayRBMH.js";import{H as d,i as b,I as P,J as A,j as v,g as B,k as q,l as z,p as U,L as C,M as D}from"./D2feDspf.js";import{c as E}from"./B0G1_45q.js";function R(n,e,i,t){if(n.type==="point")return n.x+=e,n.y+=i,n.hasZ&&t!=null,n;if(n.type==="multipoint"){const r=n.points;for(let s=0;s<r.length;s++)r[s]=k(r[s],e,i,t);return n}if(n.type==="extent")return n.xmin+=e,n.xmax+=e,n.ymin+=i,n.ymax+=i,n;const o=n.type==="polyline"?n.curvePaths??n.paths:n.curveRings??n.rings,c=B(n);for(let r=0;r<o.length;r++){const s=o[r];for(let p=0;p<s.length;p++)s[p]=G(s[p],e,i,t)}return"paths"in n?c?n.curvePaths=o:n.paths=o:c?n.curveRings=o:n.rings=o,n}function V(n,e,i,t,o){const c=n.clone();if(o){const{resolution:r}=t;R(c,e*r,-i*r)}else{const{dxMap:r,dyMap:s}=F(e,i,t);R(c,r,s)}return c}function F(n,e,i){const t=i.state.inverseTransform;return{dxMap:t[0]*n+t[2]*e,dyMap:t[1]*n+t[3]*e}}function k(n,e,i,t){return w(n,n[0]+e,n[1]+i,n[2]!=null&&t!=null?n[2]+t:void 0)}function G(n,e,i,t){const o=k(v(n),e,i,t);if(q(n))return o;if(z(n)){const[,s,p]=n.b;return{b:[o,[s[0]+e,s[1]+i],[p[0]+e,p[1]+i]]}}if(U(n)){const[,s]=n.c;return{c:[o,[s[0]+e,s[1]+i]]}}const[,c,...r]=n.a;return{a:[o,[c[0]+e,c[1]+i],...r]}}function W(n,e,i,t){if(n.type==="point"){const{x:u,y:f}=n,x=t?t[0]:u,l=t?t[1]:f,m=n.clone(),y=(u-x)*e+x,a=(f-l)*i+l;return m.x=y,m.y=a,m}if(n.type==="extent"){const{xmin:u,xmax:f,ymin:x,ymax:l}=n,m=t?t[0]:(u+f)/2,y=t?t[1]:(l+x)/2,a=n.clone();if(a.xmin=(u-m)*e+m,a.ymax=(l-y)*i+y,a.xmax=(f-m)*e+m,a.ymin=(x-y)*i+y,a.xmin>a.xmax){const h=a.xmin,M=a.xmax;a.xmin=M,a.xmax=h}if(a.ymin>a.ymax){const h=a.ymin,M=a.ymax;a.ymin=M,a.ymax=h}return a}let o=null;if(!t){o=d(n);const u=b(),f=P(u,o);if(!f)return n.clone();const[x,l,m,y]=f;t=[(x+m)/2,(l+y)/2]}const[c,r]=t;if(n.type==="multipoint"){const u=n.clone(),f=u.points;for(let x=0;x<f.length;x++){const l=f[x],[m,y]=l,a=(m-c)*e+c,h=(y-r)*i+r;f[x]=w(l,a,h,void 0)}return u.points=f,u}const s=n.clone();o??=d(n);const p=s.type==="polygon",g=p?s.curveRings??s.rings:s.curvePaths??s.paths;if(!t){const u=b(),f=P(u,g,!1,!1);if(!f)return s;t=A(f)}for(const u of g){let f=null;const x=p&&u.length>0&&T(v(u[0]),v(u.at(-1)));for(let l=0;l<u.length;l++){const m=u[l];u[l]=K(m,e,i,c,r,f),f=m}x&&(u[0]=[...v(u.at(-1))])}return s}function j(n,e,i,t,o){const[c,r,...s]=n;return[(c-t)*e+t,(r-o)*i+o,...s]}function K(n,e,i,t,o,c){if(q(n))return j(n,e,i,t,o);if(z(n)){const[H,I,J]=n.b.map(L=>j(L,e,i,t,o));return{b:[H,I,J]}}if(!c)return n;const r=v(c),s=U(n)?C(r,n):n,[p,g,u,f,x,l,m]=s.a,y=x??0,a=l??Math.hypot(p[0]-g[0],p[1]-g[1]),h=m??1,M=E(t,o,1,0,0,1,e,i);return D(r,{a:[[...p],[...g],u,f,y,a,h]},M)}function X(n,e,i,t,o,c){const r=Math.sqrt((i-n)*(i-n)+(t-e)*(t-e));return Math.sqrt((o-n)*(o-n)+(c-e)*(c-e))/r}function Y(n,e,i,t=!1){const o=Math.atan2(e.y-i.y,e.x-i.x)-Math.atan2(n.y-i.y,n.x-i.x),c=Math.atan2(Math.sin(o),Math.cos(o));return t?c:Z(c)}function w(n,e,i,t){const o=[e,i];return n.length>2&&o.push(t??n[2]),n.length>3&&o.push(n[3]),o}export{W as M,X as U,Y as b,F as h,V as x};
